import ctypes
import sys
from ctypes import *
from ctypes.wintypes import DWORD, BOOL, HWND, ULONG

from PyQt5.QtCore import QRectF
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
from PyQt5.QtGui import QPainterPath, QRegion
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, \
    QGraphicsDropShadowEffect, QFrame


# ================ 亚克力效果相关结构体和枚举 =================

class ACCENT_STATE:
    ACCENT_DISABLED = 0
    ACCENT_ENABLE_GRADIENT = 1
    ACCENT_ENABLE_TRANSPARENTGRADIENT = 2
    ACCENT_ENABLE_BLURBEHIND = 3  # Aero效果
    ACCENT_ENABLE_ACRYLICBLURBEHIND = 4  # 亚克力效果
    ACCENT_INVALID_STATE = 5


class ACCENT_POLICY(Structure):
    _fields_ = [
        ("AccentState", DWORD),
        ("AccentFlags", DWORD),
        ("GradientColor", DWORD),
        ("AnimationId", DWORD)
    ]


class WINDOWCOMPOSITIONATTRIB:
    WCA_ACCENT_POLICY = 19


class WINDOWCOMPOSITIONATTRIBDATA(Structure):
    _fields_ = [
        ("Attribute", DWORD),
        ("Data", POINTER(ACCENT_POLICY)),
        ("SizeOfData", ULONG)
    ]


# ================ 自定义标题栏 =================
class TitleBar(QFrame):
    def __init__(self, parent):
        super().__init__(parent)
        self.setFixedHeight(40)
        # 半透明背景，便于与亚克力效果融合
        self.setStyleSheet("background-color: rgba(0, 0, 0, 80);")
        self.initUI()
        self._startPos = None

    def initUI(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 0, 10, 0)
        layout.setSpacing(5)

        # 窗口标题
        self.titleLabel = QLabel("Acrylic Frameless Window")
        self.titleLabel.setStyleSheet("color: white; font-size: 16px;")
        layout.addWidget(self.titleLabel)
        layout.addStretch()

        # 最小化按钮
        self.minButton = QPushButton("-")
        self.minButton.setFixedSize(30, 30)
        self.minButton.setStyleSheet(
            "QPushButton {background-color: rgba(255,255,255,0.3); color: white; border: none; border-radius: 5px;}"
            "QPushButton:hover {background-color: rgba(255,255,255,0.5);}"
        )
        self.minButton.clicked.connect(self.onMinimize)
        layout.addWidget(self.minButton)

        # 最大化/还原按钮
        self.maxButton = QPushButton("□")
        self.maxButton.setFixedSize(30, 30)
        self.maxButton.setStyleSheet(
            "QPushButton {background-color: rgba(255,255,255,0.3); color: white; border: none; border-radius: 5px;}"
            "QPushButton:hover {background-color: rgba(255,255,255,0.5);}"
        )
        self.maxButton.clicked.connect(self.onMaximize)
        layout.addWidget(self.maxButton)

        # 关闭按钮
        self.closeButton = QPushButton("×")
        self.closeButton.setFixedSize(30, 30)
        self.closeButton.setStyleSheet(
            "QPushButton {background-color: rgba(255,0,0,0.5); color: white; border: none; border-radius: 5px;}"
            "QPushButton:hover {background-color: rgba(255,0,0,0.7);}"
        )
        self.closeButton.clicked.connect(self.onClose)
        layout.addWidget(self.closeButton)

    def onMinimize(self):
        self.window().showMinimized()

    def onMaximize(self):
        if self.window().isMaximized():
            self.window().showNormal()
            self.maxButton.setText("□")
        else:
            self.window().showMaximized()
            self.maxButton.setText("❐")  # 或其他图标

    def onClose(self):
        self.window().close()

    # 拖动窗口实现：仅在标题栏上实现拖动
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._startPos = event.globalPos()
        event.accept()

    def mouseMoveEvent(self, event):
        if self._startPos:
            delta = event.globalPos() - self._startPos
            self.window().move(self.window().pos() + delta)
            self._startPos = event.globalPos()
        event.accept()

    def mouseReleaseEvent(self, event):
        self._startPos = None
        event.accept()

    def resizeEvent(self, event):
        super().resizeEvent(event)


# ================ 主窗口：亚克力 + 无边框 + 自定义标题栏 + 边缘缩放 + 圆角 =================
class AcrylicFramelessWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._border_width = 10  # 用于边缘缩放的区域宽度判断
        self.initWindow()
        self.initAcrylicEffect()
        self.initDropShadow()
        self.initUI()
        self.updateMask()  # 初始化时设置圆角

    def initWindow(self):
        self.setWindowFlags(Qt.Window | Qt.FramelessWindowHint | Qt.WindowSystemMenuHint |
                            Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint)
        # 透明背景使亚克力效果生效
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        self.setMouseTracking(True)
        self.resize(800, 600)

    def initAcrylicEffect(self):
        hwnd = int(self.winId())
        # 使用 RGBA 十六进制颜色字符串，示例："F2F2F230"
        # 转换为 Windows 所需的 BGRA 格式
        gradientColor_str = "F2F2F230"
        gradientColor_swapped = gradientColor_str[6:] + gradientColor_str[4:6] + gradientColor_str[
                                                                                 2:4] + gradientColor_str[:2]
        gradientColor = DWORD(int(gradientColor_swapped, 16))
        accentFlags = DWORD(0x20 | 0x40 | 0x80 | 0x100)
        accent = ACCENT_POLICY()
        accent.AccentState = ACCENT_STATE.ACCENT_ENABLE_ACRYLICBLURBEHIND
        accent.GradientColor = gradientColor
        accent.AccentFlags = accentFlags
        accent.AnimationId = DWORD(0)

        data = WINDOWCOMPOSITIONATTRIBDATA()
        data.Attribute = WINDOWCOMPOSITIONATTRIB.WCA_ACCENT_POLICY
        data.Data = pointer(accent)
        data.SizeOfData = sizeof(accent)

        user32 = ctypes.windll.user32
        SetWindowCompositionAttribute = user32.SetWindowCompositionAttribute
        SetWindowCompositionAttribute.restype = BOOL
        SetWindowCompositionAttribute.argtypes = [HWND, POINTER(WINDOWCOMPOSITIONATTRIBDATA)]
        SetWindowCompositionAttribute(hwnd, pointer(data))

    def initDropShadow(self):
        # 添加阴影效果，增强窗口的立体感
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(15)
        shadow.setColor(QColor(0, 0, 0, 150))
        shadow.setOffset(0, 0)
        self.setGraphicsEffect(shadow)

    def initUI(self):
        # 主容器widget，可在此添加其他组件
        container = QWidget(self)
        container.setObjectName("container")
        container.setStyleSheet("""
            #container {
                background-color: rgba(255, 255, 255, 30);
                border-radius: 8px;
            }
        """)
        self.setCentralWidget(container)
        layout = QVBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # 添加自定义标题栏（拖动移动仅由标题栏处理）
        self.titleBar = TitleBar(self)
        layout.addWidget(self.titleBar)

        # 添加主内容区（可放置其他组件）
        content = QWidget(self)
        content.setStyleSheet("background-color: transparent;")
        layout.addWidget(content)
        content_layout = QVBoxLayout(content)
        content_layout.addStretch()
        label = QLabel("这里是窗口的主要内容区域", self)
        label.setStyleSheet("color: white; font-size: 20px;")
        label.setAlignment(Qt.AlignCenter)
        content_layout.addWidget(label)
        content_layout.addStretch()

    # 仅处理边缘缩放，不再处理整体移动
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._mouse_press_pos = event.globalPos()
            self._mouse_press_geometry = self.geometry()
            pos = event.pos()
            rect = self.rect()
            # 判断是否在边缘区域，只有在边缘区域才进入调整大小模式
            if pos.x() >= rect.width() - self._border_width and pos.y() >= rect.height() - self._border_width:
                self._resizing = True
                self._resize_direction = "bottomright"
            elif pos.x() >= rect.width() - self._border_width:
                self._resizing = True
                self._resize_direction = "right"
            elif pos.y() >= rect.height() - self._border_width:
                self._resizing = True
                self._resize_direction = "bottom"
            else:
                self._resizing = False
                self._resize_direction = None
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        pos = event.pos()
        rect = self.rect()
        if not (event.buttons() & Qt.LeftButton):
            if pos.x() >= rect.width() - self._border_width and pos.y() >= rect.height() - self._border_width:
                self.setCursor(Qt.SizeFDiagCursor)
            elif pos.x() >= rect.width() - self._border_width:
                self.setCursor(Qt.SizeHorCursor)
            elif pos.y() >= rect.height() - self._border_width:
                self.setCursor(Qt.SizeVerCursor)
            else:
                self.setCursor(Qt.ArrowCursor)
        if event.buttons() & Qt.LeftButton and getattr(self, '_resizing', False):
            delta = event.globalPos() - self._mouse_press_pos
            new_geo = self._mouse_press_geometry
            if self._resize_direction == "bottomright":
                new_width = max(new_geo.width() + delta.x(), 200)
                new_height = max(new_geo.height() + delta.y(), 150)
                self.setGeometry(new_geo.x(), new_geo.y(), new_width, new_height)
            elif self._resize_direction == "right":
                new_width = max(new_geo.width() + delta.x(), 200)
                self.setGeometry(new_geo.x(), new_geo.y(), new_width, new_geo.height())
            elif self._resize_direction == "bottom":
                new_height = max(new_geo.height() + delta.y(), 150)
                self.setGeometry(new_geo.x(), new_geo.y(), new_geo.width(), new_height)
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        self._resizing = False
        self._resize_direction = None
        self.setCursor(Qt.ArrowCursor)
        super().mouseReleaseEvent(event)

    # -------------------- 实现圆角效果 --------------------

    def updateMask(self):
        path = QPainterPath()
        path.addRoundedRect(QRectF(self.rect()), 30, 30)
        region = QRegion(path.toFillPolygon().toPolygon())
        # 给主窗口设置圆角
        self.setMask(region)
        # 同时给 central widget 设置相同的圆角掩码
        if self.centralWidget():
            self.centralWidget().setMask(region)

    def resizeEvent(self, event):
        self.updateMask()
        # self.titleBar.move(0, -40)
        super().resizeEvent(event)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = AcrylicFramelessWindow()
    window.show()
    sys.exit(app.exec_())
